### 서비스레이어에서 컨트롤러의 DTO를 사용하지 말자

서비스레이어가 특정 컨트롤러의 DTO에 의존하면 컨트롤러만 바뀐 채 같은 서비스를 쓴다면 문제가 발생함

상위 레이어는 하위 레이어를 알고 있지만 하위 레이어는 상위 레이어를 모르는게 좋음.

서비스레이어 전용 DTO를 만들어서 컨트롤러에서 서비스에 전달할 때 변환.

장점

- 컨트롤러와 서비스를 분리하기 쉽다
- 서비스레이어의 DTO는 Validation이 필요없다

조금 귀찮지만 나눠서 관리하는게 의존성, 책임 분리 측면에서 좋다

### Spring Validation에서의 @NotBlank, @NotNull, @NotEmpty

String타입에 사용할 수 있는 유효성 검사 어노테이션

- NotNull
    - "         ", “” 가능  / null 불가
- NotEmpty
    - "         " 가능  / “”, null 불가
- NotBlank
    - "         ", “”, null 불가

### Validation의 책임을 DTO에서 하는게 맞는가?

예를 들어 상품이름의 길이를 DTO에서 걸러야하나?

한번에 한 레이어에서 모든 검증을 할 필요는 없음. 책임을 분리하기 위한 생각을 해보자

상품이름 입력길이 제한은 사용자입력의 제한이라기 보다는 도메인 정책으로 보는게 타당하다

더 안쪽 레이어인 서비스 레이어나 도메인 객체를 생성할 때 검증을 하는게 맞다

### 서비스 레이어 테스트에서의 @SpringBootTest +  @Transactional

테스트마다 데이터베이스를 롤백해주기 때문에 수동으로 초기화해줄 필요 없이 편리하게 사용 가능

But  실제 서비스에 Transactional이 빠져 있어도 테스트에선 정상적으로 작동하는 것 처럼 보여 위험함

→ 팀원들이 모두 정확하게 이 부분을 이해하고 사용하거나 직접 @AfterEach tearDown 메서드에서 초기화 함수를 만들어주자!

### Layered Architecture의 단점

엔티티를 도메인 객체로 사용하고 있는데 JPA관련 어노테이션들, DB에 매핑하기 위한 코드들이 많음.

객체의 도메인 로직들이 분리가 되어야 하지 않을까? 에 대한 의문

도메인 객체와 데이터베이스 사이의 강결합.

만약 JPA를 그만 쓰고싶다면…? 

이미 코드에 JPA가 너무 깊게 침투해버린 상황

도메인 객체가 인프라 레이어와 강한 의존관계를 갖는게 맞을까라는 의문에 대한 해결방법

—> 헥사고날 아키텍쳐