### Dockerfile을 사용하여 자체 이미지 빌드하기

이미지는 모든 설정 명령과 모든 코드가 포함된 공유 가능한 패키지
컨테이너는 그러한 이미지의 구체적인 실행 인스턴스
이미지를 기반으로 하는 컨테이너를 실행해보자

### 자체 이미지를 기반으로 컨테이너 실행하기

Dockerfile을 이미지로 변환한 다음 컨테이너로 변환하는 방법

```jsx
FROM node

WORKDIR /app

COPY . /app

RUN npm install

CMD ["node", "server.js"]

EXPOSE 80

```

Dockerfile 명령에 따라 이미지를 만드는 법

```jsx
~ docker build .              
[+] Building 3.5s (9/9) FINISHED                                                                                                                 docker:desktop-linux
 => [internal] load build definition from Dockerfile                                                                                                             0.0s
 => => transferring dockerfile: 130B                                                                                                                             0.0s
 => [internal] load metadata for docker.io/library/node:latest                                                                                                   0.0s
 => [internal] load .dockerignore                                                                                                                                0.0s
 => => transferring context: 2B                                                                                                                                  0.0s
 => [1/4] FROM docker.io/library/node:latest                                                                                                                     0.0s
 => [internal] load build context                                                                                                                                0.0s
 => => transferring context: 8.25kB                                                                                                                              0.0s
 => [2/4] WORKDIR /app                                                                                                                                           0.0s
 => [3/4] COPY . /app                                                                                                                                            0.0s
 => [4/4] RUN npm install                                                                                                                                        3.4s
 => exporting to image                                                                                                                                           0.1s
 => => exporting layers                                                                                                                                          0.1s
 => => writing image sha256:7ee178b1c05a9312173219f47b4a03bcbb2c15558c026e2bbef46fed71de2323  
```

빌드된 이미지로 컨테이너 실행하기

```jsx
docker run 7ee178b1c05a9312173219f47b4a03bcbb2c15558c026e2bbef46fed71de2323 
```

CMD ["node", "server.js"]에 따라서 서버 실행

컨테이너 종료하기
```jsx
docker stop {container Id or name}
```

### 이미지는 읽기 전용!

소스코드를 변경해도 이미 만든 이미지에는 반영되지 않는다. → 컨테이너를 켰다 꺼도 소용없다

왜냐하면 소스 코드를 이미지에 기본적으로 복사한 시점에서 소스 코드의 스냅샷을 만든 것이기 때문

그럼 소스코드를 변경 할 때마다 이미지를 새로 빌드해야 할까? → 뭔가 방법이 있을듯

중요한 것은 이미지는 결국 닫힌 템플릿!

### 30. Attached & Detached컨테이너 이해하기

docker start로 컨테이너를 실행하면 터미널의 프로세스가 즉시 완료됩니다.

터미널의 실행 중인 도커 컨테이너에더 이상 이것을 연결하지 않는 거죠. (역자주: 컨테이너는 백그라운드로 실행 중입니다)

하지만 docker run을 실행한 경우, 이 프로세스에서 막힌 것을 알 수 있습니다. 타이핑은 되어도, 실행시킬 순 없죠. Enter키를 눌러 실행할 수 없습니다.

이 프로세스는 이 터미널을 차단 (역자주: 컨테이너는 포어그라운드에서 실행중입니다)

docker start 로 시작하는 경우, detached 모드가 디폴트이며,

docker run으로 실행하는 경우, attached 모드가 디폴트

왜 두 모드로 나눠놨을까?

detached모드는 콘솔에 아무것도 뜨지 않지만 attached는 콘솔에 표시 가능 → 실행중인 컨테이너에 터미널이 연결되어이씩 때문, 컨테이너의 출력결과를 수신.

```bash
# docker run 을 detached 모드로 실행하는 법

docker run -p 8000:80 -d 065a38b6
```

```bash
# docker start 을 attached 모드로 실행하는 법

docker start -p 8000:80 -a 065a38b6
```

```bash
# 분리된 컨테이너를 다시 실행하는 법

docker container attach 컨네이너_이름
```

주의!

attached모드의 컨테이너에서 ctrl + c를 쓰면  detached모드가 되는 것이 아니라 해당 컨테이너가 종료된다.

```bash
# 과거에 출력된 로그
docker logs 6d5316f3815f

# 로그 수신 대기
docker logs -f 6d5316f3815f
```

### 데이터 카테고리/다양한 종류의 데이터 이해하기

애플리케이션 - 소스코드와 애플리케이션이 실행되는 환경 / 우리가 작성한 코드와 종속성

이 코드가 빌드 단계에서 이 코드들이 이미지에 복사되고 고정되며 더 이상 변경할 수 없게 된다.

실행중인 애플리케이션의 소스코드를 변경하는건 안되기 때문에 이미지가 읽기전용인건 문제가 되지 않음

++ 두가지 다른 종류의 데이터가 있음

1. 애플리케이션이 실행되는 동안 생성된 임시 데이터
    1. 사용자의 입력 - 메모리나 데이터베이스 파일에 저장될 수 있음 / 컨테이너가 종료될 때 잃어버려도 상관없는 일시적 데이터
    2. 임시데이터는 rw이기 때문에 이미지가 아닌 컨테이너에 저장
    3. 컨테이너에 저장되는 부가 레이어(read-write layer)가 있는데 이건 도커에 의해 추가됨
    

1. 영구 애플리케이션 데이터
    1. 컨테이너가 종료되더라도 계속 생존해야만 하는 데이터
    2. 영구 애 ㅂ데이터도 read-write 데이터고 애플리케이션 실행 동안 작성되지만 영구저장 필요 → 볼륨의 도움을 받게 됨

### 문제 이해하기

도커 컨테이너를 중지하고 제거했다가 다시 켜면 이전에 만들었던 파일이 사라짐, —rm옵션을 빼고 종료 후 재시작하면 이전에 만들었던 파일이 살아있음.

그 이미지에는 호스팅 시스템 파일 시스템에서 분리된

자체 내부 파일 시스템이 있다구요.

그런 다음, 그 이미지를 기반으로 도커 컨테이너를 시작하면

그 이미지 위에 얇은 read-write 레이어로 컨테이너가 추가됩니다.

 read-write 레이어에 저장되어있는 데이터가 컨테이너를 제거 한 후에도 유지하길 원하면 어떻게 해야하지?


 ### 볼륨 소개

볼륨은 데이터를 유지하도록 돕는다

볼륨은 호스트 머신의 폴더,

컨테이너나 이미지에 있는 게 아닙니다.

즉, 호스트 컴퓨터에 장착된 하드 드라이브에 존재하여 사용가능하거나,

컨테이너로 매핑되는 것을 의미

COPY는 이미지에 복사되는 일회성 스냅샷을 만드는 역할인 반면 볼륨은 컨테이너 내부의 폴더를 호스트 머신 상의 컨테이너 외부 폴더에 연결할 수 있다

호스트 머신에 파일을 추가하면

컨테이너 내부에서 액세스할 수 있고

컨테이너가 매핑된 경로에 파일을 추가하면

컨테이너 외부, 즉 호스트 머신에서도 사용할 수 가능

볼륨은 컨테이너가 종료된 경우에도 지속되며 계속 존재

도커의 두 가지 외부 데이터 저장 메커니즘!

1. 볼륨 - 도커에 의해 관리
    1. 익명 볼륨
    2. 명명 볼륨
2. 바인드마운트 - 사용자에 의해 관리

- 익명 볼륨
    - 컨테이너에 종속되어 있음, 컨테이너가 제거될 때 같이 제거
- 명명된 볼륨
    - 컨테이너와를 제거해도 남아있음
    - 다양한 컨테이너에 명명된 볼륨 하나를 마운트 할 수 있음
- 바인드마운트
    - 호스트 머신에 데이터가 저장되는 위치를 알고 있음